<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebXR Image Tracking + Video (Aligned)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <style>
      body { margin: 0; overflow: hidden; background: #000; }
      video { display: none; } /* Hide HTML video element */
    </style>
  </head>
  <body>
    <video id="arVideo" src="video.mp4" loop playsinline muted></video>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer;
      let video, videoTexture, videoPlane;
      let refSpace = null;

      init();
      animate();

      async function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera();

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // ✅ Load and convert the marker image to ImageBitmap
        const imgResponse = await fetch('marker.jpg');
        const imgBlob = await imgResponse.blob();
        const imageBitmap = await createImageBitmap(imgBlob);

        // ✅ Add ARButton with image tracking
        const button = ARButton.createButton(renderer, {
          requiredFeatures: ['image-tracking'],
          trackedImages: [
            {
              image: imageBitmap,
              widthInMeters: 0.2061 // real printed width in meters (20.61 cm)
            }
          ]
        });
        document.body.appendChild(button);

        // ✅ Add light
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        // ✅ Setup video + texture
        video = document.getElementById('arVideo');
        videoTexture = new THREE.VideoTexture(video);
        const material = new THREE.MeshBasicMaterial({ map: videoTexture });

        // Match aspect ratio of 2061 x 1435 (≈1.436)
        const geometry = new THREE.PlaneGeometry(0.2061, 0.1435);
        videoPlane = new THREE.Mesh(geometry, material);

        // ✅ Rotate to align flat with the marker
        videoPlane.rotation.x = -Math.PI / 2;
        videoPlane.visible = false;
        scene.add(videoPlane);

        // ✅ Handle session
        renderer.xr.addEventListener('sessionstart', () => {
          const session = renderer.xr.getSession();
          session.requestReferenceSpace('local').then(space => refSpace = space);
        });

        window.addEventListener('resize', () => {
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render(timestamp, frame) {
        if (frame && refSpace) {
          const results = frame.getImageTrackingResults
            ? frame.getImageTrackingResults()
            : [];

          for (const result of results) {
            const state = result.trackingState;
            const pose = frame.getPose(result.imageSpace, refSpace);

            if (state === 'tracked' && pose) {
              videoPlane.visible = true;
              videoPlane.matrix.fromArray(pose.transform.matrix);
              videoPlane.matrixAutoUpdate = false;
              if (video.paused) video.play();
            } else if (state === 'emulated' || state === 'untracked') {
              videoPlane.visible = false;
              video.pause();
            }
          }
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
